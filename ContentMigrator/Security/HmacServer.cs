using System;
using System.Web;
using MicroCHAP;
using MicroCHAP.Server;

namespace Sidekick.ContentMigrator.Security
{
	/// <summary>
	/// Functionalities needed to be a server of CHAP-authenticated data over HTTP.
	/// Requires a persistent store of challenge values so we can avoid replay attacks.
	/// </summary>
	public class HmacServer : IChapServer
	{
		private readonly ISignatureService _responseService;
		private readonly IChallengeStore _challengeStore;

		public HmacServer(ISignatureService responseService, IChallengeStore challengeStore)
		{
			_responseService = responseService;
			_challengeStore = challengeStore;
		}

		public int TokenValidityInMs { get; set; } = 600000;

		public virtual string GetChallengeToken()
		{
			throw new NotImplementedException("Sidekick does not use CHAP, so it does not issue challenges.");
		}

		public bool ValidateRequest(HttpRequestBase request)
		{
			return ValidateRequest(request, (IChapServerLogger)null);
		}

		public bool ValidateRequest(HttpRequestBase request, IChapServerLogger logger)
		{
			return ValidateRequest(request, null, logger);
		}

		public virtual bool ValidateRequest(HttpRequestBase request, Func<HttpRequestBase, SignatureFactor[]> factorParser)
		{
			return ValidateRequest(request, factorParser, null);
		}

		public virtual bool ValidateRequest(HttpRequestBase request, Func<HttpRequestBase, SignatureFactor[]> factorParser, IChapServerLogger logger)
		{
			var authorize = request.Headers["X-MC-MAC"];
			var challenge = request.Headers["X-MC-Nonce"];

			if (authorize == null || challenge == null)
			{
				logger?.RejectedDueToMissingHttpHeaders();
				return false;
			}

			SignatureFactor[] factors = null;
			if (factorParser != null) factors = factorParser(request);

			return ValidateToken(challenge, authorize, request.Url.AbsoluteUri.TrimEnd(new[] { '/' }), logger, factors);
		}

		public virtual bool ValidateToken(string challenge, string response, string url, params SignatureFactor[] additionalFactors)
		{
			return ValidateToken(challenge, response, url, null, additionalFactors);
		}

		public virtual bool ValidateToken(string challenge, string response, string url, IChapServerLogger logger, params SignatureFactor[] additionalFactors)
		{
			// Check signature first, to avoid any DDoS vulnerabilities in challenge tracking
			var localMacOfRequest = _responseService.CreateSignature(challenge, url, additionalFactors);

			if (!localMacOfRequest.SignatureHash.Equals(response))
			{
				logger?.RejectedDueToInvalidSignature(challenge, response, localMacOfRequest);
				return false;
			}

			// if the HMAC matches, then we check that the challenge value
			// (which in this case is random generated by the client)
			// has not been used recently
			if (!_challengeStore.ConsumeChallenge(challenge))
			{
				logger?.RejectedDueToInvalidChallenge(challenge, url);
				return false; // invalid or expired challenge
			}

			return true;
		}
	}
}